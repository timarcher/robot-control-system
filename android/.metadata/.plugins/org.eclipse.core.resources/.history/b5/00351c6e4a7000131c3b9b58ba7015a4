package com.example.ioiosrf08interface;

import android.graphics.Color;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import ioio.lib.api.AnalogInput;
import ioio.lib.api.DigitalInput;
import ioio.lib.api.DigitalOutput;
import ioio.lib.api.PwmOutput;
import ioio.lib.api.TwiMaster;
import ioio.lib.api.exception.ConnectionLostException;
import ioio.lib.util.android.IOIOActivity;
import ioio.lib.util.BaseIOIOLooper;
import ioio.lib.util.IOIOLooper;

/**
 * This is the main activity of the IOIO SRF08 Sonar Interface demo application.
 * 
 * 
 */
public class MainActivity extends IOIOActivity {
	/** Pin constants / declarations */
	//See pin capabilities on https://github.com/ytai/ioio/wiki/Getting-To-Know-The-Board
	private static int PIN_I2C_SDA0						= 4;
	private static int PIN_I2C_SCL0						= 5;

	//i2c details can be found here
	//https://github.com/ytai/ioio/wiki/TWI
		
		
	TextView txtIoioStatus;
    
    /**
	 * Called when the activity is first created. Here we normally initialize
	 * our GUI.
	 */	
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
   
        setContentView(R.layout.activity_main);
        
        txtIoioStatus = (TextView) findViewById(R.id.txtIoioStatus);
    }

    
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.activity_main, menu);
        return true;
    }
    
    
	/**
	 * A method to create our IOIO thread.
	 * 
	 * @see ioio.lib.util.AbstractIOIOActivity#createIOIOThread()
	 */
	@Override
	protected IOIOLooper createIOIOLooper() {
		return new Looper();
	}	
	
	
	/**
	 * This is the thread on which all the IOIO activity happens. It will be run
	 * every time the application is resumed and aborted when it is paused. The
	 * method setup() will be called right after a connection with the IOIO has
	 * been established (which might happen several times!). Then, loop() will
	 * be called repetitively until the IOIO gets disconnected.
	 */
	class Looper extends BaseIOIOLooper {
		long loopCount = 0;
		
		/** The on-board LED. */
		private DigitalOutput led_;
				
		/** TWI (Two Wire Interface, otherwise known as I2C */
		private TwiMaster twi;
		
		/**
		 * Called every time a connection with IOIO has been established.
		 * Typically used to open pins.
		 * 
		 * @throws ConnectionLostException
		 *             When IOIO connection is lost.
		 * 
		 * @see ioio.lib.util.AbstractIOIOActivity.IOIOThread#setup()
		 */
		@Override
		protected void setup() throws ConnectionLostException {
			runOnUiThread(new Runnable() {
				public void run() {
					txtIoioStatus.setText("Setting up.");
					txtIoioStatus.setBackgroundColor(Color.GREEN);
			    }
			});			

			loopCount = 0;
			led_ = ioio_.openDigitalOutput(0, true);

			//This opens a TWI module number twiNum in master mode, using its dedicated SDA and SCL pins (specify 0, 1 or 2 for param 1)
			//The TWI module will run at 100KHz (400KHz and 1MHz also supported) 
			//and will use I²C voltage levels (pass true as third argument for SMBus levels).
			twi = ioio_.openTwiMaster(0, TwiMaster.Rate.RATE_100KHz, false);
		}

		/**
		 * Called when the IOIO has been disconnected.
		 * 
		 */
		@Override
		public void disconnected() {
			runOnUiThread(new Runnable() {
				public void run() {
					txtIoioStatus.setText("Disconnected.");
					txtIoioStatus.setBackgroundColor(Color.RED);
			    }
			});			
		}
		
		/**
		 * Called repetitively while the IOIO is connected.
		 * 
		 * @throws ConnectionLostException
		 *             When IOIO connection is lost.
		 * 
		 * @see ioio.lib.util.AbstractIOIOActivity.IOIOThread#loop()
		 */
		@Override
		public void loop() throws ConnectionLostException {
			loopCount ++;
			led_.write(true);
			
			//
			//Read from the SRF08 sonar
			//			
			try {				
				byte[] responseInitiateRanging = new byte[1];
				//Default address of the SRF08 is 0xE0
				//It can be changed by the user to any of 16 addresses E0, E2, E4, E6, E8, EA, EC, EE, F0, F2, F4, F6, F8, FA, FC or FE, therefore up to 16 sonar's can be used
				//You'll need to reprogram the SRF08 address to use anything other than 0xE0
				int sonarAddress1 = 0xE0;
				//int sonarAddress1 = 0x00;
				byte srf08CommandRegisterAddress = 0x00;
				//0x50 = ranging result in inches
				//0x51 = ranging result in centimeters
				//0x52 = ranging result in micro-seconds
				byte rangingCommand = 0x51;
				//byte[] requestInitiateRanging = new byte[] { srf08CommandRegisterAddress, rangingCommand };
				byte[] requestInitiateRanging = new byte[] { srf08CommandRegisterAddress, 0x00 };
				
				Log.d("app",  "About to initiate sonar ranging.");
				twi.writeRead(sonarAddress1, false, requestInitiateRanging, requestInitiateRanging.length, null, 0);
				
				//This will write the bytes in the request array to the device with the requested address, then read 1 byte from it. 
				//The false passed as second argument means we're using 7-bit addressing mode.
				//TwiMaster.Result result = twi.writeReadAsync(sonarAddress1, false, requestInitiateRanging, requestInitiateRanging.length, responseInitiateRanging, responseInitiateRanging.length);
				//...optionally do some stuff while the transaction is taking place...
				//blocks until response is available
				//result.waitReady();

				//twi.close();
			} catch (Exception e) {
				//do something here on exception
				Log.e("app", "Error in twi.writeRead", e);
			}
			
			/*
			srf08CommandRegisterAddress = 0x01;
			byte[] requestInitiateRead = new byte[] { srf08CommandRegisterAddress };
			try {				
				TwiMaster.Result result = twi.writeReadAsync(sonarAddress1, false, requestInitiateRead, requestInitiateRead.length, response, response.length);
				//...optionally do some stuff while the transaction is taking place...
				//blocks until response is available
				result.waitReady();
			} catch (Exception e) {
				//do something here on exception
				Log.e("", "Error in twi.writeRead", e);
			}
			*/
			
			//
			//Since the IOIO runs in its own thread, need to update the view from the UI thread
			//
			runOnUiThread(new Runnable() {
				public void run() {
					//Just some dummy status code
					txtIoioStatus.setText("Looping: " + String.valueOf(loopCount));
			    }
			});			
			
			try {
				Thread.sleep(250);
			} catch (InterruptedException e) {
			}
		}
		
		
	}
	
}
